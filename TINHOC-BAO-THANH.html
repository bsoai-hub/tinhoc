<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Flashcard H·ªçc T·ª´ V·ª±ng</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<style>
  body {
    font-family: 'Comic Neue', cursive;
    background: #fffaf2;
    color: #3c2f2f;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  h1 { margin: 20px 0; color: #5c4033; }

  .container {
    width: 90%;
    max-width: 700px;
    margin: auto;
    background: #fff8ee;
    border-radius: 16px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 20px;
  }

  select, input, button, textarea {
    font-family: inherit;
    font-size: 16px;
    padding: 8px 10px;
    margin: 5px;
    border-radius: 8px;
    border: 1px solid #ccc;
    box-sizing: border-box; /* Gi√∫p padding kh√¥ng l√†m tƒÉng k√≠ch th∆∞·ªõc */
  }
  textarea {
      width: calc(100% - 10px);
      resize: vertical;
  }
  button {
    background-color: #f4a261;
    color: white;
    cursor: pointer;
    border: none;
    transition: background-color 0.2s;
  }
  button:hover { background-color: #e76f51; }
  .delete-button { background-color: #e76f51; }
  .delete-button:hover { background-color: #d62828; }
  .export-button { background-color: #2a9d8f; }
  .export-button:hover { background-color: #264653; }
  .secondary-button { background-color: #8d99ae; }
  .secondary-button:hover { background-color: #2b2d42; }

  .section-divider {
      border-bottom: 1px solid #eee;
      margin: 15px 0;
  }
  
  /* Nh√≥m c√°c n√∫t ƒë·ªÉ d·ªÖ qu·∫£n l√Ω */
  .button-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
  }

  .flashcard {
    margin: 20px auto;
    width: 90%;
    height: 200px;
    perspective: 1000px;
    cursor: pointer;
  }

  .card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.7s;
    transform-style: preserve-3d;
  }
  .card-inner.flipped {
    transform: rotateY(180deg);
  }

  .card-face {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 16px;
    font-size: 28px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    padding: 10px; /* Th√™m padding ƒë·ªÉ ch·ªØ kh√¥ng b·ªã s√°t l·ªÅ */
    box-sizing: border-box;
  }

  .front { background: #fefae0; color: #4b2e05; }
  .back { background: #faedcd; color: #4b2e05; transform: rotateY(180deg); }

  .controls button { margin: 5px; }

  .progress-bar {
    width: 100%;
    height: 10px;
    background: #eee;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 8px;
  }
  .progress {
    height: 10px;
    width: 0%;
    background: #f4a261;
    transition: width 0.5s;
  }

  .stats { margin-top: 10px; font-size: 14px; color: #5a3312; }
  
  .instructions {
    margin-top: 15px;
    padding: 10px 15px;
    background: #fdfaf6;
    border-radius: 8px;
    border: 1px solid #eee;
    text-align: left;
  }
  .instructions summary {
    font-weight: bold;
    cursor: pointer;
    color: #5c4033;
    list-style-type: 'üìñ ';
  }
  .instructions p, .instructions ul {
    margin-top: 10px;
  }
  .instructions ul {
    padding-left: 25px;
  }
  .instructions li {
    margin-bottom: 5px;
  }

  #reviewModeNotice {
      display: none;
      background-color: #e9c46a;
      padding: 10px;
      border-radius: 8px;
      margin-top: 15px;
      font-weight: bold;
  }

  /* --- CSS CHO GIAO DI·ªÜN DI ƒê·ªòNG --- */
  @media (max-width: 768px) {
    .container {
        width: 95%;
        padding: 10px;
    }
    h1 {
        font-size: 24px;
    }
    .flashcard {
        height: 180px; /* Gi·∫£m chi·ªÅu cao th·∫ª */
    }
    .card-face {
        font-size: 22px; /* Gi·∫£m c·ª° ch·ªØ tr√™n th·∫ª */
    }

    /* Cho c√°c input v√† n√∫t chi·∫øm 100% chi·ªÅu r·ªông ƒë·ªÉ d·ªÖ nh·∫•n */
    input[type="text"], input[type="file"], select, #add-edit-area button {
        width: calc(100% - 10px);
    }
    #add-edit-area {
        display: flex;
        flex-direction: column;
    }
    .controls .button-group {
        flex-direction: column;
    }
    .controls button {
        width: calc(100% - 10px);
    }
  }

</style>
</head>
<body>
  <h1>üìö Flashcard H·ªçc T·ª´ V·ª±ng</h1>
  <div class="container">
    <div>
      <select id="deckSelect" onchange="changeDeck()"></select>
      <input type="text" id="newDeckName" placeholder="T√™n b·ªô m·ªõi">
      <button onclick="addDeck()">Th√™m b·ªô</button>
      <button onclick="deleteDeck()" class="delete-button">X√≥a b·ªô</button>
      <button onclick="exportToExcel()" class="export-button">Xu·∫•t ra Excel</button>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="button-group">
        <button onclick="reviewForgotten()" class="secondary-button">üß† √în t·ª´ ƒë√£ qu√™n</button>
        <button onclick="shuffleDeck()" class="secondary-button">üîÄ X√°o tr·ªôn</button>
        <button onclick="resetProgress()" class="secondary-button">üîÑ Reset ti·∫øn ƒë·ªô</button>
    </div>

    <div class="section-divider"></div>

    <div id="add-edit-area">
      <input id="wordInput" placeholder="T·ª´ ti·∫øng Anh">
      <input id="meaningInput" placeholder="Nghƒ©a ti·∫øng Vi·ªát">
      <button id="addCardBtn" onclick="addOrUpdateCard()">Th√™m th·∫ª</button>
      <button id="cancelEditBtn" onclick="cancelEdit()" style="display:none;" class="secondary-button">H·ªßy</button>
    </div>

    <div style="margin-top: 10px; padding: 10px; background: #fdfaf6; border-radius: 8px;">
        <label for="excel-input" style="font-size: 15px;">Ho·∫∑c nh·∫≠p t·ª´ file Excel:</label><br>
        <input type="file" id="excel-input" accept=".xlsx, .xls, .csv" style="margin-top: 5px;">
        <button onclick="importFromExcel()">T·∫£i l√™n</button>
    </div>

    <details class="instructions">
      <summary>Xem h∆∞·ªõng d·∫´n t·∫°o file Excel</summary>
      <div>
        <p>ƒê·ªÉ nh·∫≠p t·ª´ v·ª±ng t·ª´ file Excel, h√£y ch·∫Øc ch·∫Øn file c·ªßa b·∫°n ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng ƒë√∫ng c√°ch:</p>
        <ul>
          <li>File ph·∫£i c√≥ ƒë·ªãnh d·∫°ng <strong>.xlsx</strong>, <strong>.xls</strong> ho·∫∑c <strong>.csv</strong>.</li>
          <li><strong>C·ªôt A:</strong> Ch·ª©a c√°c t·ª´ v·ª±ng ti·∫øng Anh.</li>
          <li><strong>C·ªôt B:</strong> Ch·ª©a nghƒ©a ti·∫øng Vi·ªát t∆∞∆°ng ·ª©ng.</li>
          <li>Kh√¥ng c·∫ßn c√≥ d√≤ng ti√™u ƒë·ªÅ. Ch∆∞∆°ng tr√¨nh s·∫Ω ƒë·ªçc d·ªØ li·ªáu b·∫Øt ƒë·∫ßu t·ª´ d√≤ng ƒë·∫ßu ti√™n.</li>
        </ul>
      </div>
    </details>

    <div id="reviewModeNotice">
        ƒêang ·ªü ch·∫ø ƒë·ªô √¥n t·∫≠p c√°c t·ª´ ƒë√£ qu√™n.
        <button onclick="exitReviewMode()" style="margin-left: 15px;">Tho√°t ch·∫ø ƒë·ªô</button>
    </div>

    <div class="flashcard" id="flashcard" onclick="flipCard()">
      <div class="card-inner" id="cardInner">
        <div class="card-face front" id="frontFace">Hello</div>
        <div class="card-face back" id="backFace">Xin ch√†o</div>
      </div>
    </div>

    <div class="controls">
      <div class="button-group">
          <button onclick="prevCard()">‚¨ÖÔ∏è Tr∆∞·ªõc</button>
          <button onclick="nextCard()">‚û°Ô∏è Ti·∫øp</button>
      </div>
      <div class="button-group">
          <button onclick="markRemembered()">‚úÖ Nh·ªõ (A)</button>
          <button onclick="markForgot()">‚ùå Qu√™n (D)</button>
      </div>
       <div class="button-group">
          <button onclick="speakWord()">üîä Ph√°t √¢m</button>
          <button onclick="startEditCard()" class="secondary-button">‚úèÔ∏è S·ª≠a th·∫ª</button>
          <button onclick="deleteCard()" class="delete-button">üóëÔ∏è X√≥a th·∫ª</button>
      </div>
    </div>

    <div class="progress-bar"><div class="progress" id="progress"></div></div>
    <div class="stats" id="stats"></div>
  </div>

<script>
// --- Default decks (you can expand later) ---
const defaultDecks = {
  "Gia ƒë√¨nh": [
    ["father","cha"],["mother","m·∫π"],["brother","anh/em trai"],["sister","ch·ªã/em g√°i"],["grandfather","√¥ng"],
    ["grandmother","b√†"],["son","con trai"],["daughter","con g√°i"],["uncle","ch√∫/c·∫≠u"],["aunt","d√¨/c√¥"]
  ],
  "Ch√†o h·ªèi": [
    ["hello","xin ch√†o"],["hi","ch√†o"],["good morning","ch√†o bu·ªïi s√°ng"],["good night","ch√∫c ng·ªß ngon"],["see you","h·∫πn g·∫∑p l·∫°i"]
  ],
  "C√¥ng vi·ªác": [
    ["job","c√¥ng vi·ªác"],["office","vƒÉn ph√≤ng"],["meeting","cu·ªôc h·ªçp"],["boss","s·∫øp"],["colleague","ƒë·ªìng nghi·ªáp"]
  ],
};

// --- Load / state ---
let decks = JSON.parse(localStorage.getItem('flashcardDecks')) || defaultDecks;
let progress = JSON.parse(localStorage.getItem('flashcardProgress')) || {};
let currentDeck = Object.keys(decks)[0] || null;
let currentIndex = 0;
let flipped = false;
let editingIndex = -1; // -1 means not editing
let isReviewMode = false;
let originalDeckData = [];

// --- DOM refs ---
const deckSelect = document.getElementById('deckSelect');
const cardInner = document.getElementById('cardInner');
const frontFace = document.getElementById('frontFace');
const backFace = document.getElementById('backFace');
const stats = document.getElementById('stats');
const progressBar = document.getElementById('progress');
const wordInput = document.getElementById('wordInput');
const meaningInput = document.getElementById('meaningInput');
const addCardBtn = document.getElementById('addCardBtn');
const cancelEditBtn = document.getElementById('cancelEditBtn');
const reviewModeNotice = document.getElementById('reviewModeNotice');

// --- init ---
function init() {
  exitReviewMode(); // Ensure not in review mode on start
  renderDeckOptions();
  if (currentDeck && decks[currentDeck]) {
      deckSelect.value = currentDeck;
  } else if (Object.keys(decks).length > 0) {
      currentDeck = Object.keys(decks)[0];
      deckSelect.value = currentDeck;
  } else {
      currentDeck = null;
  }
  cancelEdit();
  showCard();
}
function renderDeckOptions() {
  const deckKeys = Object.keys(decks);
  deckSelect.innerHTML = deckKeys.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`).join('');
  if(deckKeys.length === 0){
      deckSelect.innerHTML = '<option>Kh√¥ng c√≥ b·ªô n√†o</option>';
  }
}
function escapeHtml(s) {
    return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

init();

// --- persistence ---
function save() {
  localStorage.setItem('flashcardDecks', JSON.stringify(decks));
  localStorage.setItem('flashcardProgress', JSON.stringify(progress));
}

// --- deck operations ---
function addDeck() {
  exitReviewMode();
  const name = document.getElementById('newDeckName').value.trim();
  if(!name) return alert("Nh·∫≠p t√™n b·ªô m·ªõi!");
  if(decks[name]) return alert("B·ªô n√†y ƒë√£ t·ªìn t·∫°i!");
  decks[name] = [];
  currentDeck = name;
  document.getElementById('newDeckName').value = '';
  save();
  init();
}

function changeDeck() {
  exitReviewMode();
  currentDeck = deckSelect.value;
  currentIndex = 0;
  showCard();
}

function deleteDeck() {
    exitReviewMode();
    const deckToDelete = deckSelect.value;
    if (!deckToDelete || !decks[deckToDelete]) {
        return alert("Kh√¥ng c√≥ b·ªô n√†o ƒë·ªÉ x√≥a.");
    }
    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b·ªô "${deckToDelete}"? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`)) {
        return;
    }

    delete decks[deckToDelete];
    if (progress[deckToDelete]) {
        delete progress[deckToDelete];
    }

    const remainingDecks = Object.keys(decks);
    currentDeck = remainingDecks.length > 0 ? remainingDecks[0] : null;
    currentIndex = 0;

    save();
    init();
}

function shuffleDeck() {
    if(!currentDeck || !decks[currentDeck] || decks[currentDeck].length < 2) return;
    const deck = decks[currentDeck];
    // Fisher-Yates shuffle
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    currentIndex = 0;
    showCard();
    alert(`ƒê√£ x√°o tr·ªôn b·ªô "${currentDeck}"!`);
}

function resetProgress() {
    if (!currentDeck || !progress[currentDeck]) return alert("B·ªô n√†y ch∆∞a c√≥ ti·∫øn ƒë·ªô ƒë·ªÉ reset.");
    if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën reset ti·∫øn ƒë·ªô h·ªçc c·ªßa b·ªô "${currentDeck}" kh√¥ng?`)) {
        progress[currentDeck] = { remembered: [], forgotten: [] };
        save();
        updateStats();
        alert("ƒê√£ reset ti·∫øn ƒë·ªô th√†nh c√¥ng.");
    }
}

// --- Review Mode ---
function reviewForgotten() {
    if (isReviewMode) return;
    if (!currentDeck || !progress[currentDeck] || !progress[currentDeck].forgotten || progress[currentDeck].forgotten.length === 0) {
        return alert("Kh√¥ng c√≥ t·ª´ n√†o ƒë∆∞·ª£c ƒë√°nh d·∫•u 'Qu√™n' trong b·ªô n√†y.");
    }

    const forgottenWords = new Set(progress[currentDeck].forgotten);
    originalDeckData = [...decks[currentDeck]]; // Backup original deck
    const reviewDeck = originalDeckData.filter(card => forgottenWords.has(card[0]));
    
    if (reviewDeck.length === 0) {
         return alert("Kh√¥ng c√≥ t·ª´ n√†o ƒë∆∞·ª£c ƒë√°nh d·∫•u 'Qu√™n' trong b·ªô n√†y.");
    }

    decks[currentDeck] = reviewDeck;
    isReviewMode = true;
    reviewModeNotice.style.display = 'block';
    currentIndex = 0;
    showCard();
}

function exitReviewMode() {
    if (!isReviewMode) return;
    
    // Restore original deck if it exists
    if (originalDeckData.length > 0) {
        decks[currentDeck] = originalDeckData;
        originalDeckData = [];
    }
    
    isReviewMode = false;
    reviewModeNotice.style.display = 'none';
    currentIndex = 0; 
    showCard();
}

// --- H√ÄM XU·∫§T B·ªò RA FILE EXCEL ---
function exportToExcel() {
    if (!currentDeck) return alert("Vui l√≤ng ch·ªçn m·ªôt b·ªô ƒë·ªÉ xu·∫•t ra Excel.");
    const deckData = decks[currentDeck];
    if (!deckData || deckData.length === 0) return alert("B·ªô n√†y ƒëang tr·ªëng, kh√¥ng th·ªÉ xu·∫•t.");
    const dataForExport = deckData;
    const worksheet = XLSX.utils.aoa_to_sheet(dataForExport);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, currentDeck);
    XLSX.writeFile(workbook, `${currentDeck}.xlsx`);
}

// --- NH·∫¨P T·ª™ FILE EXCEL ---
function importFromExcel() {
    if (!currentDeck) return alert("Vui l√≤ng t·∫°o ho·∫∑c ch·ªçn m·ªôt b·ªô tr∆∞·ªõc khi nh·∫≠p!");
    const fileInput = document.getElementById('excel-input');
    const file = fileInput.files[0];
    if (!file) return alert("Vui l√≤ng ch·ªçn m·ªôt file Excel.");

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            let importedCount = 0;
            const currentDeckData = decks[currentDeck];
            const existingWords = new Set(currentDeckData.map(card => card[0].toLowerCase().trim()));

            for (const row of jsonData) {
                if (row && row.length >= 2) {
                    const word = String(row[0] || '').trim();
                    const meaning = String(row[1] || '').trim();

                    if (word && meaning && !existingWords.has(word.toLowerCase())) {
                        currentDeckData.push([word, meaning]);
                        existingWords.add(word.toLowerCase());
                        importedCount++;
                    }
                }
            }

            if (importedCount > 0) {
                save();
                currentIndex = 0; 
                showCard();
                alert(`ƒê√£ nh·∫≠p th√†nh c√¥ng ${importedCount} th·∫ª m·ªõi v√†o b·ªô "${currentDeck}"!`);
            } else {
                alert("Kh√¥ng c√≥ th·∫ª m·ªõi n√†o ƒë∆∞·ª£c nh·∫≠p. File c√≥ th·ªÉ tr·ªëng ho·∫∑c c√°c t·ª´ ƒë√£ t·ªìn t·∫°i.");
            }
        } catch (error) {
            console.error("L·ªói khi x·ª≠ l√Ω file Excel:", error);
            alert("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng file.");
        } finally {
            fileInput.value = '';
        }
    };
    reader.readAsArrayBuffer(file);
}

// --- card ops ---
function addOrUpdateCard() {
  if(!currentDeck) return alert("Vui l√≤ng t·∫°o m·ªôt b·ªô tr∆∞·ªõc!");
  const word = wordInput.value.trim();
  const mean = meaningInput.value.trim();
  if(!word || !mean) return alert("Nh·∫≠p ƒë·ªß t·ª´ v√† nghƒ©a!");
  
  if (editingIndex > -1) { // We are in edit mode
      decks[currentDeck][editingIndex] = [word, mean];
      const oldIndex = editingIndex;
      cancelEdit(); // Reset UI
      currentIndex = oldIndex;
      showCard();
  } else { // We are adding a new card
      decks[currentDeck].push([word, mean]);
      currentIndex = decks[currentDeck].length - 1;
      showCard();
  }
  save();
  wordInput.value = '';
  meaningInput.value = '';
  wordInput.focus();
}

function startEditCard() {
    if (!currentDeck || decks[currentDeck].length === 0) return;
    editingIndex = currentIndex;
    const [word, meaning] = decks[currentDeck][editingIndex];
    wordInput.value = word;
    meaningInput.value = meaning;
    addCardBtn.textContent = 'L∆∞u thay ƒë·ªïi';
    cancelEditBtn.style.display = 'inline-block';
    wordInput.focus();
}

function cancelEdit() {
    editingIndex = -1;
    wordInput.value = '';
    meaningInput.value = '';
    addCardBtn.textContent = 'Th√™m th·∫ª';
    cancelEditBtn.style.display = 'none';
}

function deleteCard() {
  if(!currentDeck) return;
  const deck = decks[currentDeck];
  if(!deck || deck.length === 0) return alert("Kh√¥ng c√≥ th·∫ª ƒë·ªÉ x√≥a.");
  if(!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a th·∫ª n√†y?")) return;
  deck.splice(currentIndex,1);
  if (currentIndex >= deck.length) {
      currentIndex = Math.max(0, deck.length - 1);
  }
  save();
  showCard();
}

function showCard() {
  cancelEdit();
  if (!currentDeck || !decks[currentDeck]) {
    frontFace.textContent = "Ch√†o m·ª´ng!";
    backFace.textContent = "T·∫°o m·ªôt b·ªô m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu.";
    cardInner.classList.remove('flipped');
    flipped = false;
    updateStats();
    return;
  }

  const deck = decks[currentDeck] || [];
  if(deck.length === 0) {
    frontFace.textContent = "Ch∆∞a c√≥ th·∫ª";
    backFace.textContent = "H√£y th√™m t·ª´ m·ªõi!";
    cardInner.classList.remove('flipped');
    flipped = false;
    if (currentIndex != 0) currentIndex = 0; 
    updateStats();
    return;
  }
  
  if (currentIndex >= deck.length) {
      currentIndex = deck.length - 1;
  }

  const [w,m] = deck[currentIndex];
  frontFace.textContent = w;
  backFace.textContent = m;
  cardInner.classList.remove('flipped');
  flipped = false;
  updateStats();
}

function flipCard() {
  if (!currentDeck || decks[currentDeck].length === 0) return;
  flipped = !flipped;
  cardInner.classList.toggle('flipped', flipped);
}

// navigation
function nextCard() {
  const deck = decks[currentDeck] || [];
  if(deck.length === 0) return;
  currentIndex = (currentIndex + 1) % deck.length;
  showCard();
}
function prevCard() {
  const deck = decks[currentDeck] || [];
  if(deck.length === 0) return;
  currentIndex = (currentIndex - 1 + deck.length) % deck.length;
  showCard();
}

// remember / forgot
function markRemembered() {
  if(!currentDeck) return;
  const deck = decks[currentDeck] || [];
  if (deck.length === 0) return;
  if(!progress[currentDeck]) progress[currentDeck] = { remembered: [], forgotten: [] };
  const word = deck[currentIndex]?.[0];
  if(!word) return;
  if(!progress[currentDeck].remembered.includes(word)) progress[currentDeck].remembered.push(word);
  progress[currentDeck].forgotten = (progress[currentDeck].forgotten || []).filter(w => w !== word);
  save();
  updateStats();
  nextCard();
}
function markForgot() {
  if(!currentDeck) return;
  const deck = decks[currentDeck] || [];
  if (deck.length === 0) return;
  if(!progress[currentDeck]) progress[currentDeck] = { remembered: [], forgotten: [] };
  const word = deck[currentIndex]?.[0];
  if(!word) return;
  if(!progress[currentDeck].forgotten.includes(word)) progress[currentDeck].forgotten.push(word);
  progress[currentDeck].remembered = (progress[currentDeck].remembered || []).filter(w => w !== word);
  save();
  updateStats();
  nextCard();
}

// speak
function speakWord() {
  if(!currentDeck) return;
  const deck = decks[currentDeck] || [];
  if (deck.length === 0) return;
  const word = deck[currentIndex]?.[0];
  if(!word) return;
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  speechSynthesis.speak(u);
}

// stats / progress
function updateStats() {
    if (!currentDeck) {
        stats.innerHTML = "Ch∆∞a ch·ªçn b·ªô n√†o";
        progressBar.style.width = '0%';
        return;
    }
  // The deck for stats should be the original one in review mode
  const deckForStats = isReviewMode ? originalDeckData : (decks[currentDeck] || []);
  const prog = progress[currentDeck] || { remembered: [], forgotten: [] };
  const total = deckForStats.length;
  const remembered = prog.remembered ? prog.remembered.length : 0;
  const forgotten = prog.forgotten ? prog.forgotten.length : 0;
  const percent = total ? Math.round((remembered / total) * 100) : 0;
  
  const currentTotal = decks[currentDeck]?.length || 0;
  const currentCardNumber = currentTotal > 0 ? currentIndex + 1 : 0;
  stats.innerHTML = `B·ªô: <b>${escapeHtml(currentDeck)}</b><br>Th·∫ª ${currentCardNumber}/${currentTotal} &nbsp;|&nbsp; Ti·∫øn ƒë·ªô chung: ${remembered}/${total} ƒë√£ nh·ªõ (${percent}%)`;
  progressBar.style.width = percent + '%';
}

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
    // Stop if user is typing in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }

    switch (e.key) {
        case 'ArrowLeft':
            prevCard();
            break;
        case 'ArrowRight':
            nextCard();
            break;
        case ' ': // Spacebar
            e.preventDefault(); // Prevent page scrolling
            flipCard();
            break;
        case 's':
        case 'S':
            speakWord();
            break;
        case 'a':
        case 'A':
            markRemembered();
            break;
        case 'd':
        case 'D':
            markForgot();
            break;
    }
});

// Save periodically
window.addEventListener('beforeunload', save);
</script>
</body>
</html>