<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Flashcard H·ªçc T·ª´ V·ª±ng</title>
<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<style>
  body {
    font-family: 'Comic Neue', cursive;
    background: #fffaf2;
    color: #3c2f2f;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  h1 { margin: 20px 0; color: #5c4033; }

  .container {
    width: 90%;
    max-width: 700px;
    margin: auto;
    background: #fff8ee;
    border-radius: 16px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 20px;
  }

  select, input, button {
    font-family: inherit;
    font-size: 16px;
    padding: 8px 10px;
    margin: 5px;
    border-radius: 8px;
    border: 1px solid #ccc;
  }
  button {
    background-color: #f4a261;
    color: white;
    cursor: pointer;
    border: none;
  }
  button:hover { background-color: #e76f51; }
  .delete-button {
    background-color: #e76f51;
  }
  .delete-button:hover {
    background-color: #d62828;
  }
  .section-divider {
      border-bottom: 1px solid #eee;
      margin: 15px 0;
  }

  .flashcard {
    margin: 20px auto;
    width: 90%;
    height: 200px;
    perspective: 1000px;
    cursor: pointer;
  }

  .card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.7s;
    transform-style: preserve-3d;
  }
  .card-inner.flipped {
    transform: rotateY(180deg);
  }

  .card-face {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 16px;
    font-size: 28px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }

  .front { background: #fefae0; color: #4b2e05; }
  .back { background: #faedcd; color: #4b2e05; transform: rotateY(180deg); }

  .controls button { margin: 5px; }

  .progress-bar {
    width: 100%;
    height: 10px;
    background: #eee;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 8px;
  }
  .progress {
    height: 10px;
    width: 0%;
    background: #f4a261;
    transition: width 0.5s;
  }

  .stats { margin-top: 10px; font-size: 14px; color: #5a3312; }
  
  /* CSS cho ph·∫ßn h∆∞·ªõng d·∫´n */
  .instructions {
    margin-top: 15px;
    padding: 10px 15px;
    background: #fdfaf6;
    border-radius: 8px;
    border: 1px solid #eee;
    text-align: left;
  }
  .instructions summary {
    font-weight: bold;
    cursor: pointer;
    color: #5c4033;
    list-style-type: 'üìñ ';
  }
  .instructions p, .instructions ul {
    margin-top: 10px;
  }
  .instructions ul {
    padding-left: 25px;
  }
  .instructions li {
    margin-bottom: 5px;
  }
</style>
</head>
<body>
  <h1>üìö Flashcard H·ªçc T·ª´ V·ª±ng</h1>
  <div class="container">
    <div>
      <select id="deckSelect" onchange="changeDeck()"></select>
      <input type="text" id="newDeckName" placeholder="T√™n b·ªô m·ªõi">
      <button onclick="addDeck()">Th√™m b·ªô</button>
      <button onclick="deleteDeck()" class="delete-button">X√≥a b·ªô</button>
    </div>

    <div class="section-divider"></div>

    <div>
      <input id="wordInput" placeholder="T·ª´ ti·∫øng Anh">
      <input id="meaningInput" placeholder="Nghƒ©a ti·∫øng Vi·ªát">
      <button onclick="addCard()">Th√™m th·∫ª</button>
      <button onclick="deleteCard()" class="delete-button">X√≥a th·∫ª hi·ªán t·∫°i</button>
    </div>

    <div style="margin-top: 10px; padding: 10px; background: #fdfaf6; border-radius: 8px;">
        <label for="excel-input" style="font-size: 15px;">Ho·∫∑c nh·∫≠p t·ª´ file Excel:</label><br>
        <input type="file" id="excel-input" accept=".xlsx, .xls, .csv" style="margin-top: 5px;">
        <button onclick="importFromExcel()">T·∫£i l√™n</button>
    </div>

    <details class="instructions">
      <summary>Xem h∆∞·ªõng d·∫´n t·∫°o file Excel</summary>
      <div>
        <p>ƒê·ªÉ nh·∫≠p t·ª´ v·ª±ng t·ª´ file Excel, h√£y ch·∫Øc ch·∫Øn file c·ªßa b·∫°n ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng ƒë√∫ng c√°ch:</p>
        <ul>
          <li>File ph·∫£i c√≥ ƒë·ªãnh d·∫°ng <strong>.xlsx</strong>, <strong>.xls</strong> ho·∫∑c <strong>.csv</strong>.</li>
          <li><strong>C·ªôt A:</strong> Ch·ª©a c√°c t·ª´ v·ª±ng ti·∫øng Anh.</li>
          <li><strong>C·ªôt B:</strong> Ch·ª©a nghƒ©a ti·∫øng Vi·ªát t∆∞∆°ng ·ª©ng.</li>
          <li>Kh√¥ng c·∫ßn c√≥ d√≤ng ti√™u ƒë·ªÅ. Ch∆∞∆°ng tr√¨nh s·∫Ω ƒë·ªçc d·ªØ li·ªáu b·∫Øt ƒë·∫ßu t·ª´ d√≤ng ƒë·∫ßu ti√™n.</li>
        </ul>
      </div>
    </details>

    <div class="flashcard" id="flashcard" onclick="flipCard()">
      <div class="card-inner" id="cardInner">
        <div class="card-face front" id="frontFace">Hello</div>
        <div class="card-face back" id="backFace">Xin ch√†o</div>
      </div>
    </div>

    <div class="controls">
      <button onclick="prevCard()">‚¨ÖÔ∏è Tr∆∞·ªõc</button>
      <button onclick="speakWord()">üîä Ph√°t √¢m</button>
      <button onclick="nextCard()">‚û°Ô∏è Ti·∫øp</button><br>
      <button onclick="markRemembered()">‚úÖ Nh·ªõ</button>
      <button onclick="markForgot()">‚ùå Qu√™n</button>
    </div>

    <div class="progress-bar"><div class="progress" id="progress"></div></div>
    <div class="stats" id="stats"></div>
  </div>

<script>
// --- Default decks (you can expand later) ---
const defaultDecks = {
  "Gia ƒë√¨nh": [
    ["father","cha"],["mother","m·∫π"],["brother","anh/em trai"],["sister","ch·ªã/em g√°i"],["grandfather","√¥ng"],
    ["grandmother","b√†"],["son","con trai"],["daughter","con g√°i"],["uncle","ch√∫/c·∫≠u"],["aunt","d√¨/c√¥"]
  ],
  "Ch√†o h·ªèi": [
    ["hello","xin ch√†o"],["hi","ch√†o"],["good morning","ch√†o bu·ªïi s√°ng"],["good night","ch√∫c ng·ªß ngon"],["see you","h·∫πn g·∫∑p l·∫°i"]
  ],
  "C√¥ng vi·ªác": [
    ["job","c√¥ng vi·ªác"],["office","vƒÉn ph√≤ng"],["meeting","cu·ªôc h·ªçp"],["boss","s·∫øp"],["colleague","ƒë·ªìng nghi·ªáp"]
  ],
};

// --- Load / state ---
let decks = JSON.parse(localStorage.getItem('flashcardDecks')) || defaultDecks;
let progress = JSON.parse(localStorage.getItem('flashcardProgress')) || {};
let currentDeck = Object.keys(decks)[0] || null;
let currentIndex = 0;
let flipped = false;

// --- DOM refs ---
const deckSelect = document.getElementById('deckSelect');
const cardInner = document.getElementById('cardInner');
const frontFace = document.getElementById('frontFace');
const backFace = document.getElementById('backFace');
const stats = document.getElementById('stats');
const progressBar = document.getElementById('progress');

// --- init ---
function init() {
  renderDeckOptions();
  if (currentDeck) {
      deckSelect.value = currentDeck;
  }
  showCard();
}
function renderDeckOptions() {
  const deckKeys = Object.keys(decks);
  deckSelect.innerHTML = deckKeys.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`).join('');
  if(deckKeys.length === 0){
      deckSelect.innerHTML = '<option>Kh√¥ng c√≥ b·ªô n√†o</option>';
  }
}
function escapeHtml(s){ return (''+s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

init();

// --- persistence ---
function save() {
  localStorage.setItem('flashcardDecks', JSON.stringify(decks));
  localStorage.setItem('flashcardProgress', JSON.stringify(progress));
}

// --- deck operations ---
function addDeck() {
  const name = document.getElementById('newDeckName').value.trim();
  if(!name) return alert("Nh·∫≠p t√™n b·ªô m·ªõi!");
  if(decks[name]) return alert("B·ªô n√†y ƒë√£ t·ªìn t·∫°i!");
  decks[name] = [];
  currentDeck = name;
  document.getElementById('newDeckName').value = '';
  save();
  init();
}

function changeDeck() {
  currentDeck = deckSelect.value;
  currentIndex = 0;
  showCard();
}

function deleteDeck() {
    const deckToDelete = deckSelect.value;
    if (!deckToDelete || !decks[deckToDelete]) {
        return alert("Kh√¥ng c√≥ b·ªô n√†o ƒë·ªÉ x√≥a.");
    }
    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b·ªô "${deckToDelete}"? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`)) {
        return;
    }

    delete decks[deckToDelete];
    if (progress[deckToDelete]) {
        delete progress[deckToDelete];
    }

    const remainingDecks = Object.keys(decks);
    currentDeck = remainingDecks.length > 0 ? remainingDecks[0] : null;
    currentIndex = 0;

    save();
    init();
}

// --- Import from Excel ---
function importFromExcel() {
    if (!currentDeck) {
        return alert("Vui l√≤ng t·∫°o ho·∫∑c ch·ªçn m·ªôt b·ªô tr∆∞·ªõc khi nh·∫≠p!");
    }

    const fileInput = document.getElementById('excel-input');
    const file = fileInput.files[0];

    if (!file) {
        return alert("Vui l√≤ng ch·ªçn m·ªôt file Excel.");
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            let importedCount = 0;
            const currentDeckData = decks[currentDeck];
            const existingWords = new Set(currentDeckData.map(card => card[0].toLowerCase().trim()));

            for (const row of jsonData) {
                if (row && row.length >= 2) {
                    const word = String(row[0] || '').trim();
                    const meaning = String(row[1] || '').trim();

                    if (word && meaning && !existingWords.has(word.toLowerCase())) {
                        currentDeckData.push([word, meaning]);
                        existingWords.add(word.toLowerCase());
                        importedCount++;
                    }
                }
            }

            if (importedCount > 0) {
                save();
                currentIndex = 0;
                showCard();
                alert(`ƒê√£ nh·∫≠p th√†nh c√¥ng ${importedCount} th·∫ª m·ªõi!`);
            } else {
                alert("Kh√¥ng c√≥ th·∫ª m·ªõi n√†o ƒë∆∞·ª£c nh·∫≠p. File c√≥ th·ªÉ tr·ªëng ho·∫∑c c√°c t·ª´ ƒë√£ t·ªìn t·∫°i.");
            }
        } catch (error) {
            console.error("L·ªói khi x·ª≠ l√Ω file Excel:", error);
            alert("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng file.");
        } finally {
            fileInput.value = '';
        }
    };

    reader.onerror = function() {
        alert("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc file.");
        fileInput.value = '';
    }

    reader.readAsArrayBuffer(file);
}


// --- card ops ---
function addCard() {
  if(!currentDeck) return alert("Vui l√≤ng t·∫°o m·ªôt b·ªô tr∆∞·ªõc khi th√™m th·∫ª!");
  const word = document.getElementById('wordInput').value.trim();
  const mean = document.getElementById('meaningInput').value.trim();
  if(!word || !mean) return alert("Nh·∫≠p ƒë·ªß t·ª´ v√† nghƒ©a!");
  decks[currentDeck].push([word, mean]);
  currentIndex = decks[currentDeck].length - 1;
  save();
  document.getElementById('wordInput').value = '';
  document.getElementById('meaningInput').value = '';
  showCard();
}

function deleteCard() {
  if(!currentDeck) return;
  const deck = decks[currentDeck];
  if(!deck || deck.length === 0) return alert("Kh√¥ng c√≥ th·∫ª ƒë·ªÉ x√≥a.");
  if(!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a th·∫ª n√†y?")) return;
  deck.splice(currentIndex,1);
  if (currentIndex >= deck.length) {
      currentIndex = Math.max(0, deck.length - 1);
  }
  save();
  showCard();
}

function showCard() {
  if (!currentDeck || !decks[currentDeck]) {
    frontFace.textContent = "Ch√†o m·ª´ng!";
    backFace.textContent = "T·∫°o m·ªôt b·ªô m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu.";
    cardInner.classList.remove('flipped');
    flipped = false;
    updateStats();
    return;
  }

  const deck = decks[currentDeck] || [];
  if(deck.length === 0) {
    frontFace.textContent = "Ch∆∞a c√≥ th·∫ª";
    backFace.textContent = "H√£y th√™m t·ª´ m·ªõi!";
    cardInner.classList.remove('flipped');
    flipped = false;
    updateStats();
    return;
  }
  const [w,m] = deck[currentIndex];
  frontFace.textContent = w;
  backFace.textContent = m;
  cardInner.classList.remove('flipped');
  flipped = false;
  updateStats();
}

function flipCard() {
  flipped = !flipped;
  cardInner.classList.toggle('flipped', flipped);
}

// navigation
function nextCard() {
  const deck = decks[currentDeck] || [];
  if(deck.length === 0) return;
  currentIndex = (currentIndex + 1) % deck.length;
  showCard();
}
function prevCard() {
  const deck = decks[currentDeck] || [];
  if(deck.length === 0) return;
  currentIndex = (currentIndex - 1 + deck.length) % deck.length;
  showCard();
}

// remember / forgot
function markRemembered() {
  if(!currentDeck) return;
  if(!progress[currentDeck]) progress[currentDeck] = { remembered: [], forgotten: [] };
  const word = decks[currentDeck][currentIndex]?.[0];
  if(!word) return;
  if(!progress[currentDeck].remembered.includes(word)) progress[currentDeck].remembered.push(word);
  progress[currentDeck].forgotten = (progress[currentDeck].forgotten || []).filter(w => w !== word);
  save();
  updateStats();
  nextCard();
}
function markForgot() {
  if(!currentDeck) return;
  if(!progress[currentDeck]) progress[currentDeck] = { remembered: [], forgotten: [] };
  const word = decks[currentDeck][currentIndex]?.[0];
  if(!word) return;
  if(!progress[currentDeck].forgotten.includes(word)) progress[currentDeck].forgotten.push(word);
  progress[currentDeck].remembered = (progress[currentDeck].remembered || []).filter(w => w !== word);
  save();
  updateStats();
  nextCard();
}

// speak
function speakWord() {
  if(!currentDeck) return;
  const word = decks[currentDeck][currentIndex]?.[0];
  if(!word) return;
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  speechSynthesis.speak(u);
}

// stats / progress
function updateStats() {
    if (!currentDeck) {
        stats.innerHTML = "Ch∆∞a ch·ªçn b·ªô n√†o";
        progressBar.style.width = '0%';
        return;
    }
  const deck = decks[currentDeck] || [];
  const prog = progress[currentDeck] || { remembered: [], forgotten: [] };
  const total = deck.length;
  const remembered = prog.remembered ? prog.remembered.length : 0;
  const forgotten = prog.forgotten ? prog.forgotten.length : 0;
  const percent = total ? Math.round((remembered / total) * 100) : 0;
  
  const currentCardNumber = total > 0 ? currentIndex + 1 : 0;
  stats.innerHTML = `B·ªô: <b>${escapeHtml(currentDeck)}</b><br>Th·∫ª ${currentCardNumber}/${total} &nbsp;|&nbsp; Nh·ªõ: ${remembered} &nbsp;|&nbsp; Qu√™n: ${forgotten} (${percent}%)`;
  progressBar.style.width = percent + '%';
}

// Save periodically
window.addEventListener('beforeunload', save);
</script>
</body>
</html>