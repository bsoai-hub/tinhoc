<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Flashcard Há»c Tá»« Vá»±ng</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<style>
  body {
    font-family: 'Comic Neue', cursive;
    background: #fffaf2;
    color: #3c2f2f;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  h1 { margin: 20px 0; color: #5c4033; }

  .container {
    width: 90%;
    max-width: 700px;
    margin: auto;
    background: #fff8ee;
    border-radius: 16px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 20px;
  }

  select, input, button, textarea {
    font-family: inherit;
    font-size: 16px;
    padding: 8px 10px;
    margin: 5px;
    border-radius: 8px;
    border: 1px solid #ccc;
    box-sizing: border-box;
  }
  textarea {
      width: calc(100% - 10px);
      resize: vertical;
  }
  button {
    background-color: #f4a261;
    color: white;
    cursor: pointer;
    border: none;
    transition: background-color 0.2s;
  }
  button:hover { background-color: #e76f51; }
  .delete-button { background-color: #e76f51; }
  .delete-button:hover { background-color: #d62828; }
  .export-button { background-color: #2a9d8f; }
  .export-button:hover { background-color: #264653; }
  .secondary-button { background-color: #8d99ae; }
  .secondary-button:hover { background-color: #2b2d42; }

  .section-divider {
      border-bottom: 1px solid #eee;
      margin: 15px 0;
  }

  .flashcard {
    margin: 20px auto;
    width: 90%;
    height: 200px;
    perspective: 1000px;
    cursor: pointer;
  }

  .card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.7s;
    transform-style: preserve-3d;
  }
  .card-inner.flipped {
    transform: rotateY(180deg);
  }

  .card-face {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 16px;
    font-size: 28px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    padding: 10px; /* ThÃªm padding Ä‘á»ƒ chá»¯ khÃ´ng bá»‹ sÃ¡t lá» */
    box-sizing: border-box; /* Äáº£m báº£o padding khÃ´ng lÃ m tÄƒng kÃ­ch thÆ°á»›c */
  }

  .front { background: #fefae0; color: #4b2e05; }
  .back { background: #faedcd; color: #4b2e05; transform: rotateY(180deg); }

  .controls button { margin: 5px; }

  .progress-bar {
    width: 100%;
    height: 10px;
    background: #eee;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 8px;
  }
  .progress {
    height: 10px;
    width: 0%;
    background: #f4a261;
    transition: width 0.5s;
  }

  .stats { margin-top: 10px; font-size: 14px; color: #5a3312; }
  
  .instructions {
    margin-top: 15px;
    padding: 10px 15px;
    background: #fdfaf6;
    border-radius: 8px;
    border: 1px solid #eee;
    text-align: left;
  }
  .instructions summary {
    font-weight: bold;
    cursor: pointer;
    color: #5c4033;
    list-style-type: 'ğŸ“– ';
  }
  .instructions p, .instructions ul {
    margin-top: 10px;
  }
  .instructions ul {
    padding-left: 25px;
  }
  .instructions li {
    margin-bottom: 5px;
  }

  #reviewModeNotice {
      display: none;
      background-color: #e9c46a;
      padding: 10px;
      border-radius: 8px;
      margin-top: 15px;
      font-weight: bold;
  }

  .external-game-button {
      display: inline-block;
      margin-top: 10px;
      padding: 8px 15px;
      background-color: #2a9d8f;
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-size: 15px;
      transition: background-color 0.2s;
  }
  .external-game-button:hover {
      background-color: #264653;
  }

  /* --- CSS CHO GIAO DIá»†N ÄIá»†N THOáº I --- */
  @media (max-width: 768px) {
    body {
      font-size: 16px; /* TÄƒng cá»¡ chá»¯ cÆ¡ báº£n cho dá»… Ä‘á»c */
    }
    .container {
      width: 95%; /* Chiáº¿m gáº§n háº¿t chiá»u rá»™ng */
      padding: 15px;
    }
    h1 {
      font-size: 26px; /* Giáº£m cá»¡ chá»¯ tiÃªu Ä‘á» */
    }
    .flashcard {
      height: 220px; /* TÄƒng chiá»u cao má»™t chÃºt cho chá»¯ to hÆ¡n */
    }
    .card-face {
      font-size: 24px; /* Giáº£m cá»¡ chá»¯ trÃªn tháº» */
    }
    /* Sáº¯p xáº¿p cÃ¡c nÃºt Ä‘iá»u khiá»ƒn chÃ­nh */
    .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
    }
    .controls button {
      width: 48%; /* Hai nÃºt trÃªn má»™t hÃ ng */
      margin: 4px 0;
      padding: 12px 5px; /* TÄƒng padding cho dá»… báº¥m */
      font-size: 15px;
    }

    /* CÃ¡c nÃºt thÃªm tháº» vÃ  input */
    #add-edit-area {
        display: flex;
        flex-direction: column; /* Xáº¿p chá»“ng lÃªn nhau */
    }
    #add-edit-area input, 
    #add-edit-area button {
        width: 100%; /* Cho cÃ¡c input vÃ  nÃºt chiáº¿m háº¿t chiá»u rá»™ng */
        margin-left: 0;
        margin-right: 0;
    }
    .instructions summary {
        line-height: 1.4; /* TÄƒng khoáº£ng cÃ¡ch dÃ²ng cho dá»… Ä‘á»c */
    }
    .external-game-button {
        width: 100%;
        box-sizing: border-box;
    }
  }

  @media (max-width: 480px) {
     .card-face {
        font-size: 20px; /* Chá»¯ nhá» hÆ¡n ná»¯a trÃªn mÃ n hÃ¬nh ráº¥t nhá» */
     }
     .controls button {
        padding: 10px 5px;
        font-size: 14px;
     }
     h1 {
        font-size: 22px;
     }
  }

</style>
</head>
<body>
  <h1>ğŸ“š Flashcard Há»c Tá»« Vá»±ng</h1>
  <div class="container">
    <div>
      <select id="deckSelect" onchange="changeDeck()"></select>
      <input type="text" id="newDeckName" placeholder="TÃªn bá»™ má»›i">
      <button onclick="addDeck()">ThÃªm bá»™</button>
      <button onclick="deleteDeck()" class="delete-button">XÃ³a bá»™</button>
      <button onclick="exportToExcel()" class="export-button">Xuáº¥t ra Excel</button>
    </div>
    
    <div class="section-divider"></div>
    
    <div>
        <button onclick="reviewForgotten()" class="secondary-button">ğŸ§  Ã”n tá»« Ä‘Ã£ quÃªn</button>
        <button onclick="shuffleDeck()" class="secondary-button">ğŸ”€ XÃ¡o trá»™n</button>
        <button onclick="resetProgress()" class="secondary-button">ğŸ”„ Reset tiáº¿n Ä‘á»™</button>
    </div>

    <div class="section-divider"></div>

    <div id="add-edit-area">
      <input id="wordInput" placeholder="Tá»« tiáº¿ng Anh">
      <input id="meaningInput" placeholder="NghÄ©a tiáº¿ng Viá»‡t">
      <button id="addCardBtn" onclick="addOrUpdateCard()">ThÃªm tháº»</button>
      <button id="cancelEditBtn" onclick="cancelEdit()" style="display:none;" class="secondary-button">Há»§y</button>
    </div>

    <div style="margin-top: 10px; padding: 10px; background: #fdfaf6; border-radius: 8px;">
        <label for="excel-input" style="font-size: 15px;">Hoáº·c nháº­p tá»« file Excel:</label><br>
        <input type="file" id="excel-input" accept=".xlsx, .xls, .csv" style="margin-top: 5px;">
        <button onclick="importFromExcel()">Táº£i lÃªn</button>
    </div>

    <details class="instructions">
      <summary>Xem hÆ°á»›ng dáº«n táº¡o file Excel</summary>
      <div>
        <p>Äá»ƒ nháº­p tá»« vá»±ng tá»« file Excel, hÃ£y cháº¯c cháº¯n file cá»§a báº¡n Ä‘Æ°á»£c Ä‘á»‹nh dáº¡ng Ä‘Ãºng cÃ¡ch:</p>
        <ul>
          <li>File pháº£i cÃ³ Ä‘á»‹nh dáº¡ng <strong>.xlsx</strong>, <strong>.xls</strong> hoáº·c <strong>.csv</strong>.</li>
          <li><strong>Cá»™t A:</strong> Chá»©a cÃ¡c tá»« vá»±ng tiáº¿ng Anh.</li>
          <li><strong>Cá»™t B:</strong> Chá»©a nghÄ©a tiáº¿ng Viá»‡t tÆ°Æ¡ng á»©ng.</li>
          <li>KhÃ´ng cáº§n cÃ³ dÃ²ng tiÃªu Ä‘á». ChÆ°Æ¡ng trÃ¬nh sáº½ Ä‘á»c dá»¯ liá»‡u báº¯t Ä‘áº§u tá»« dÃ²ng Ä‘áº§u tiÃªn.</li>
        </ul>
      </div>
    </details>

    <div id="reviewModeNotice">
        Äang á»Ÿ cháº¿ Ä‘á»™ Ã´n táº­p cÃ¡c tá»« Ä‘Ã£ quÃªn.
        <button onclick="exitReviewMode()" style="margin-left: 15px;">ThoÃ¡t cháº¿ Ä‘á»™</button>
    </div>

    <div class="flashcard" id="flashcard" onclick="flipCard()">
      <div class="card-inner" id="cardInner">
        <div class="card-face front" id="frontFace">Hello</div>
        <div class="card-face back" id="backFace">Xin chÃ o</div>
      </div>
    </div>

    <div class="controls">
      <button onclick="prevCard()">â¬…ï¸ TrÆ°á»›c</button>
      <button onclick="speakWord()">ğŸ”Š PhÃ¡t Ã¢m</button>
      <button onclick="nextCard()">â¡ï¸ Tiáº¿p</button>
      <button onclick="markRemembered()">âœ… Nhá»› (A)</button>
      <button onclick="markForgot()">âŒ QuÃªn (D)</button>
      <button onclick="startEditCard()" class="secondary-button">âœï¸ Sá»­a tháº»</button>
      <button onclick="deleteCard()" class="delete-button">ğŸ—‘ï¸ XÃ³a tháº»</button>
    </div>

    <div class="progress-bar"><div class="progress" id="progress"></div></div>
    <div class="stats" id="stats"></div>
    
  

  </div>

<script>
// --- Default decks (you can expand later) ---
const defaultDecks = {
  "Gia Ä‘Ã¬nh": [
    ["father","cha"],["mother","máº¹"],["brother","anh/em trai"],["sister","chá»‹/em gÃ¡i"],["grandfather","Ã´ng"],
    ["grandmother","bÃ "],["son","con trai"],["daughter","con gÃ¡i"],["uncle","chÃº/cáº­u"],["aunt","dÃ¬/cÃ´"]
  ],
  "ChÃ o há»i": [
    ["hello","xin chÃ o"],["hi","chÃ o"],["good morning","chÃ o buá»•i sÃ¡ng"],["good night","chÃºc ngá»§ ngon"],["see you","háº¹n gáº·p láº¡i"]
  ],
  "CÃ´ng viá»‡c": [
    ["job","cÃ´ng viá»‡c"],["office","vÄƒn phÃ²ng"],["meeting","cuá»™c há»p"],["boss","sáº¿p"],["colleague","Ä‘á»“ng nghiá»‡p"]
  ],
};

// --- Load / state ---
let decks = JSON.parse(localStorage.getItem('flashcardDecks')) || defaultDecks;
let progress = JSON.parse(localStorage.getItem('flashcardProgress')) || {};
let currentDeck = Object.keys(decks)[0] || null;
let currentIndex = 0;
let flipped = false;
let editingIndex = -1; // -1 means not editing
let isReviewMode = false;
let originalDeckData = [];

// --- DOM refs ---
const deckSelect = document.getElementById('deckSelect');
const cardInner = document.getElementById('cardInner');
const frontFace = document.getElementById('frontFace');
const backFace = document.getElementById('backFace');
const stats = document.getElementById('stats');
const progressBar = document.getElementById('progress');
const wordInput = document.getElementById('wordInput');
const meaningInput = document.getElementById('meaningInput');
const addCardBtn = document.getElementById('addCardBtn');
const cancelEditBtn = document.getElementById('cancelEditBtn');
const reviewModeNotice = document.getElementById('reviewModeNotice');

// --- init ---
function init() {
  exitReviewMode(); // Ensure not in review mode on start
  renderDeckOptions();
  if (currentDeck && decks[currentDeck]) {
      deckSelect.value = currentDeck;
  } else if (Object.keys(decks).length > 0) {
      currentDeck = Object.keys(decks)[0];
      deckSelect.value = currentDeck;
  } else {
      currentDeck = null;
  }
  cancelEdit();
  showCard();
}
function renderDeckOptions() {
  const deckKeys = Object.keys(decks);
  deckSelect.innerHTML = deckKeys.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`).join('');
  if(deckKeys.length === 0){
      deckSelect.innerHTML = '<option>KhÃ´ng cÃ³ bá»™ nÃ o</option>';
  }
}
function escapeHtml(s) {
    return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

init();

// --- persistence ---
function save() {
  localStorage.setItem('flashcardDecks', JSON.stringify(decks));
  localStorage.setItem('flashcardProgress', JSON.stringify(progress));
}

// --- deck operations ---
function addDeck() {
  exitReviewMode();
  const name = document.getElementById('newDeckName').value.trim();
  if(!name) return alert("Nháº­p tÃªn bá»™ má»›i!");
  if(decks[name]) return alert("Bá»™ nÃ y Ä‘Ã£ tá»“n táº¡i!");
  decks[name] = [];
  currentDeck = name;
  document.getElementById('newDeckName').value = '';
  save();
  init();
}

function changeDeck() {
  exitReviewMode();
  currentDeck = deckSelect.value;
  currentIndex = 0;
  showCard();
}

function deleteDeck() {
    exitReviewMode();
    const deckToDelete = deckSelect.value;
    if (!deckToDelete || !decks[deckToDelete]) {
        return alert("KhÃ´ng cÃ³ bá»™ nÃ o Ä‘á»ƒ xÃ³a.");
    }
    if (!confirm(`Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a bá»™ "${deckToDelete}"? HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c.`)) {
        return;
    }

    delete decks[deckToDelete];
    if (progress[deckToDelete]) {
        delete progress[deckToDelete];
    }

    const remainingDecks = Object.keys(decks);
    currentDeck = remainingDecks.length > 0 ? remainingDecks[0] : null;
    currentIndex = 0;

    save();
    init();
}

function shuffleDeck() {
    if(!currentDeck || !decks[currentDeck] || decks[currentDeck].length < 2) return;
    const deck = decks[currentDeck];
    // Fisher-Yates shuffle
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    currentIndex = 0;
    showCard();
    alert(`ÄÃ£ xÃ¡o trá»™n bá»™ "${currentDeck}"!`);
}

function resetProgress() {
    if (!currentDeck || !progress[currentDeck]) return alert("Bá»™ nÃ y chÆ°a cÃ³ tiáº¿n Ä‘á»™ Ä‘á»ƒ reset.");
    if (confirm(`Báº¡n cÃ³ cháº¯c muá»‘n reset tiáº¿n Ä‘á»™ há»c cá»§a bá»™ "${currentDeck}" khÃ´ng?`)) {
        progress[currentDeck] = { remembered: [], forgotten: [] };
        save();
        updateStats();
        alert("ÄÃ£ reset tiáº¿n Ä‘á»™ thÃ nh cÃ´ng.");
    }
}

// --- Review Mode ---
function reviewForgotten() {
    if (isReviewMode) return;
    if (!currentDeck || !progress[currentDeck] || !progress[currentDeck].forgotten || progress[currentDeck].forgotten.length === 0) {
        return alert("KhÃ´ng cÃ³ tá»« nÃ o Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u 'QuÃªn' trong bá»™ nÃ y.");
    }

    const forgottenWords = new Set(progress[currentDeck].forgotten);
    originalDeckData = [...decks[currentDeck]]; // Backup original deck
    const reviewDeck = originalDeckData.filter(card => forgottenWords.has(card[0]));
    
    if (reviewDeck.length === 0) {
         return alert("KhÃ´ng cÃ³ tá»« nÃ o Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u 'QuÃªn' trong bá»™ nÃ y.");
    }

    decks[currentDeck] = reviewDeck;
    isReviewMode = true;
    reviewModeNotice.style.display = 'block';
    currentIndex = 0;
    showCard();
}

function exitReviewMode() {
    if (!isReviewMode) return;
    
    // Restore original deck if it exists
    if (originalDeckData.length > 0) {
        decks[currentDeck] = originalDeckData;
        originalDeckData = [];
    }
    
    isReviewMode = false;
    reviewModeNotice.style.display = 'none';
    currentIndex = 0; 
    showCard();
}

// --- HÃ€M XUáº¤T Bá»˜ RA FILE EXCEL ---
function exportToExcel() {
    if (!currentDeck) return alert("Vui lÃ²ng chá»n má»™t bá»™ Ä‘á»ƒ xuáº¥t ra Excel.");
    const deckData = decks[currentDeck];
    if (!deckData || deckData.length === 0) return alert("Bá»™ nÃ y Ä‘ang trá»‘ng, khÃ´ng thá»ƒ xuáº¥t.");
    const dataForExport = deckData;
    const worksheet = XLSX.utils.aoa_to_sheet(dataForExport);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, currentDeck);
    XLSX.writeFile(workbook, `${currentDeck}.xlsx`);
}

// --- NHáº¬P Tá»ª FILE EXCEL ---
function importFromExcel() {
    if (!currentDeck) return alert("Vui lÃ²ng táº¡o hoáº·c chá»n má»™t bá»™ trÆ°á»›c khi nháº­p!");
    const fileInput = document.getElementById('excel-input');
    const file = fileInput.files[0];
    if (!file) return alert("Vui lÃ²ng chá»n má»™t file Excel.");

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            let importedCount = 0;
            const currentDeckData = decks[currentDeck];
            const existingWords = new Set(currentDeckData.map(card => card[0].toLowerCase().trim()));

            for (const row of jsonData) {
                if (row && row.length >= 2) {
                    const word = String(row[0] || '').trim();
                    const meaning = String(row[1] || '').trim();

                    if (word && meaning && !existingWords.has(word.toLowerCase())) {
                        currentDeckData.push([word, meaning]);
                        existingWords.add(word.toLowerCase());
                        importedCount++;
                    }
                }
            }

            if (importedCount > 0) {
                save();
                currentIndex = 0; 
                showCard();
                alert(`ÄÃ£ nháº­p thÃ nh cÃ´ng ${importedCount} tháº» má»›i vÃ o bá»™ "${currentDeck}"!`);
            } else {
                alert("KhÃ´ng cÃ³ tháº» má»›i nÃ o Ä‘Æ°á»£c nháº­p. File cÃ³ thá»ƒ trá»‘ng hoáº·c cÃ¡c tá»« Ä‘Ã£ tá»“n táº¡i.");
            }
        } catch (error) {
            console.error("Lá»—i khi xá»­ lÃ½ file Excel:", error);
            alert("ÄÃ£ xáº£y ra lá»—i khi xá»­ lÃ½ file. Vui lÃ²ng kiá»ƒm tra Ä‘á»‹nh dáº¡ng file.");
        } finally {
            fileInput.value = '';
        }
    };
    reader.readAsArrayBuffer(file);
}

// --- card ops ---
function addOrUpdateCard() {
  if(!currentDeck) return alert("Vui lÃ²ng táº¡o má»™t bá»™ trÆ°á»›c!");
  const word = wordInput.value.trim();
  const mean = meaningInput.value.trim();
  if(!word || !mean) return alert("Nháº­p Ä‘á»§ tá»« vÃ  nghÄ©a!");
  
  if (editingIndex > -1) { // We are in edit mode
      decks[currentDeck][editingIndex] = [word, mean];
      const oldIndex = editingIndex;
      cancelEdit(); // Reset UI
      currentIndex = oldIndex;
      showCard();
  } else { // We are adding a new card
      decks[currentDeck].push([word, mean]);
      currentIndex = decks[currentDeck].length - 1;
      showCard();
  }
  save();
  wordInput.value = '';
  meaningInput.value = '';
  wordInput.focus();
}

function startEditCard() {
    if (!currentDeck || decks[currentDeck].length === 0) return;
    editingIndex = currentIndex;
    const [word, meaning] = decks[currentDeck][editingIndex];
    wordInput.value = word;
    meaningInput.value = meaning;
    addCardBtn.textContent = 'LÆ°u thay Ä‘á»•i';
    cancelEditBtn.style.display = 'inline-block';
    wordInput.focus();
}

function cancelEdit() {
    editingIndex = -1;
    wordInput.value = '';
    meaningInput.value = '';
    addCardBtn.textContent = 'ThÃªm tháº»';
    cancelEditBtn.style.display = 'none';
}

function deleteCard() {
  if(!currentDeck) return;
  const deck = decks[currentDeck];
  if(!deck || deck.length === 0) return alert("KhÃ´ng cÃ³ tháº» Ä‘á»ƒ xÃ³a.");
  if(!confirm("Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a tháº» nÃ y?")) return;
  deck.splice(currentIndex,1);
  if (currentIndex >= deck.length) {
      currentIndex = Math.max(0, deck.length - 1);
  }
  save();
  showCard();
}

function showCard() {
  cancelEdit();
  if (!currentDeck || !decks[currentDeck]) {
    frontFace.textContent = "ChÃ o má»«ng!";
    backFace.textContent = "Táº¡o má»™t bá»™ má»›i Ä‘á»ƒ báº¯t Ä‘áº§u.";
    cardInner.classList.remove('flipped');
    flipped = false;
    updateStats();
    return;
  }

  const deck = decks[currentDeck] || [];
  if(deck.length === 0) {
    frontFace.textContent = "ChÆ°a cÃ³ tháº»";
    backFace.textContent = "HÃ£y thÃªm tá»« má»›i!";
    cardInner.classList.remove('flipped');
    flipped = false;
    if (currentIndex != 0) currentIndex = 0; 
    updateStats();
    return;
  }
  
  if (currentIndex >= deck.length) {
      currentIndex = deck.length - 1;
  }

  const [w,m] = deck[currentIndex];
  frontFace.textContent = w;
  backFace.textContent = m;
  cardInner.classList.remove('flipped');
  flipped = false;
  updateStats();
}

function flipCard() {
  if (!currentDeck || decks[currentDeck].length === 0) return;
  flipped = !flipped;
  cardInner.classList.toggle('flipped', flipped);
}

// navigation
function nextCard() {
  const deck = decks[currentDeck] || [];
  if(deck.length === 0) return;
  currentIndex = (currentIndex + 1) % deck.length;
  showCard();
}
function prevCard() {
  const deck = decks[currentDeck] || [];
  if(deck.length === 0) return;
  currentIndex = (currentIndex - 1 + deck.length) % deck.length;
  showCard();
}

// remember / forgot
function markRemembered() {
  if(!currentDeck) return;
  const deck = decks[currentDeck] || [];
  if (deck.length === 0) return;
  if(!progress[currentDeck]) progress[currentDeck] = { remembered: [], forgotten: [] };
  const word = deck[currentIndex]?.[0];
  if(!word) return;
  if(!progress[currentDeck].remembered.includes(word)) progress[currentDeck].remembered.push(word);
  progress[currentDeck].forgotten = (progress[currentDeck].forgotten || []).filter(w => w !== word);
  save();
  updateStats();
  nextCard();
}
function markForgot() {
  if(!currentDeck) return;
  const deck = decks[currentDeck] || [];
  if (deck.length === 0) return;
  if(!progress[currentDeck]) progress[currentDeck] = { remembered: [], forgotten: [] };
  const word = deck[currentIndex]?.[0];
  if(!word) return;
  if(!progress[currentDeck].forgotten.includes(word)) progress[currentDeck].forgotten.push(word);
  progress[currentDeck].remembered = (progress[currentDeck].remembered || []).filter(w => w !== word);
  save();
  updateStats();
  nextCard();
}

// speak
function speakWord() {
  if(!currentDeck) return;
  const deck = decks[currentDeck] || [];
  if (deck.length === 0) return;
  const word = deck[currentIndex]?.[0];
  if(!word) return;
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  speechSynthesis.speak(u);
}

// stats / progress
function updateStats() {
    if (!currentDeck) {
        stats.innerHTML = "ChÆ°a chá»n bá»™ nÃ o";
        progressBar.style.width = '0%';
        return;
    }
  // The deck for stats should be the original one in review mode
  const deckForStats = isReviewMode ? originalDeckData : (decks[currentDeck] || []);
  const prog = progress[currentDeck] || { remembered: [], forgotten: [] };
  const total = deckForStats.length;
  const remembered = prog.remembered ? prog.remembered.length : 0;
  const forgotten = prog.forgotten ? prog.forgotten.length : 0;
  const percent = total ? Math.round((remembered / total) * 100) : 0;
  
  const currentTotal = decks[currentDeck]?.length || 0;
  const currentCardNumber = currentTotal > 0 ? currentIndex + 1 : 0;
  stats.innerHTML = `Bá»™: <b>${escapeHtml(currentDeck)}</b><br>Tháº» ${currentCardNumber}/${currentTotal} &nbsp;|&nbsp; Tiáº¿n Ä‘á»™ chung: ${remembered}/${total} Ä‘Ã£ nhá»› (${percent}%)`;
  progressBar.style.width = percent + '%';
}

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
    // Stop if user is typing in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }

    switch (e.key) {
        case 'ArrowLeft':
            prevCard();
            break;
        case 'ArrowRight':
            nextCard();
            break;
        case ' ': // Spacebar
            e.preventDefault(); // Prevent page scrolling
            flipCard();
            break;
        case 's':
        case 'S':
            speakWord();
            break;
        case 'a':
        case 'A':
            markRemembered();
            break;
        case 'd':
        case 'D':
            markForgot();
            break;
    }
});

// Save periodically
window.addEventListener('beforeunload', save);
</script>
</body>
</html>
